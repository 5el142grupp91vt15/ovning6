Övning 6: Bibliotek
Linux som utvecklingsmiljö, VT15
Anders Axelsson, 1986-04-08-6234
2015-03-04

Del 1
Jag implementerade biblioteket component (libcomponent.c). Biblioteket 
innehåller en funktion e_resistance och dess syfte är att beräkna 
ersättningsresistansen som kan erhållas med seriekopplade resistanser 
ur E12-serien. Funktionen tar två argument: sökt resistans och en 
array. Funktionen returnerar antalet resistanselement som krävs för 
att erhålla ersättningsresistansen genom return och exakt vilka 
resistanselement som föreslås genom arrayen som skickats som argument.

Biblioteket component används genom att inkludera libcomponent.h i 
filen som biblioteket ska användas i och placera libcomponent.so i en 
sökväg som finns i $PATH. Därefter behöver man allokera utrymme för en 
array med tre element, sen är det bara att anropa funktionen 
e_resistance.

Testprogrammet componenttest.c testar component genom att anropa 
funktionen e_resistance med olika värden och skriver ut skillnaden 
mellan originalresistansen och ersättningsresistansen, vilka E12 
element som använts samt hur många dessa är. Värdena på 
originalresistanserna är valda efter värden inom E12-serien som 
funktionen ska klara av att hitta en erästtningsresistans av utan något 
fel och värden utanför som funktionen inte väntas klara av.

Testprogrammet kompilerade jag genom att använda följande kommando:
	gcc -Wall -o componenttest componenttest.c -lcomponent
* -Wall: aktiverar alla warningar som gcc kan ge.
* -o: namn på binär som gcc kompilerar.
* -l: namn på bibliotek att länka (exklusive prefix lib och 
      filändelse .so).

Algoritmen som funktionen e_resistance använder för att finna 
ersättningsresistansen utgår från en fullständig uppräkning av alla 
kombinationer som kan göras med värdena från E12-serien. För varje 
kombination beräknas det absoluta fel som erhålls vid jämförelse med 
målresistansen. Om felet från den aktuella kombinationen är mindre än 
det hittills lägsta felet uppdateras variabeln med det lägsta felet 
hittills funnet. Dessutom sparas den resistanskombination som 
producerade felvärdet genom tre indexsiffror från E12-serien. Om 
felvärde 0 erhålls då avbryts sökandet och funktionen returnerar.

Del 2
I make-filen har jag skapat ett mål med samma namn som .o-filerna biblioteken 
skapar vid kompilering. Dessa mål har respektive biblioteks .c- och .h-fil i listan 
som förutsättningar. 
Receptet som körs för dessa mål är följande: 
    gcc -c -fPIC <biblioteksnamn>.c.
-c
-fPIC

För varje bibliotek har jag även skapat varsitt mål med samma namn som .so-filerna 
biblioteken skapar när .o-filerna länkas till delade bibliotek. Dessa mål har 
respektive biblioteks .o-fil som förutsättning. Receptet som körs för dessa mål är 
följande: 
    gcc -shared -fPIC -o <biblioteksnamn>.so <biblioteksnamn>.o
-shared
-o

Huvudprogrammet kompileras till en .o-fil i ett eget mål med main.c och main.h som 
förutsättningar. I ett annat mål 'electrotest' länkas huvudprogrammet med biblioteken 
och skapar en exekverbar fil. Detta mål
kör följande recept:
    gcc -L./lib -Wall -o electrotest main.o -lresistance -lpower -lcomponent
Flaggan -L anger var kompilatorn ska leta efter biblioteken, i detta fall under 
lib-mappen i den mapp som kommandot körs från.
-Wall
-l

Ytterligare två mål finns som knyter ihop kompileringen och länkningen av huvudprogram 
och bibliotek. Målet 'lib' har inget recept (dummy) men anropar .so-målen för bibioteken 
om .so-filerna har förändrats. Målet 'all' har 'lib' och 'electrotest' som förutsättningar 
och receptet kopierar bibliotekens .so-filer till mappen lib.

I målet 'install' kopieras bibliotekens .so-filer till /usr/lib och huvyudprogrammet till 
/usr/bin. I huvudprogrammet (main.c) inkluderar jag header-filerna för varje bibliotek med 
varsitt inkluderingsdirektiv. Funktionerna i respektive bibliotek används i huvudprogrammet 
genom att anropa korrekt funktionssignatur.

Jag sammarbetade med Tobias Lindberg och Ludvig Klingspor.

Del 3
Sammarbetet har gått bra, vi använde facebook för att prata med 
varandra och git för versionshantering. Vi testade varandras kod och 
hittade några problem som vi diskuterade och löste. I ett betydligt 
större projekt behövs också dessa delar, men mer strikta regler för 
vad man får pusha till repot tror jag. Kanske behövs enhetstester 
köras lokalt innan, kanske behövs någon form av kodstilskontroll typ 
checkstyle, kanske behövs kodgranskning typ gerrit. För att garantera 
att koden inte är felaktig kanske man behöver regresionstestning typ 
jenkins som körs kontinuerligt.  


